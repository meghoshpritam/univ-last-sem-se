# -*- coding: utf-8 -*-
"""jensen_curve.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TkEVNaMFfDAR-KqrHVgPYZkTBiyOn0Ca
"""

# Commented out IPython magic to ensure Python compatibility.
C=float(input("Enter the effective technology  constant:"))
T=float(input("Enter the development time:"))
K=float(input("Enter the effort needed to develop:"))
L=C*T*pow(K,1/3)
print("The product size is: ",L,"KLOC")



import math
import matplotlib.pyplot as plt
# %matplotlib inline
def Jensen(k,td,t):
  return(C*T*pow(K,1/3)) 

def R_curve(k,td,t):
    project_duration=3*int(td)
    y=[round(Jensen(k,td,i),5) for i in range(0, project_duration)]
    
    plt.plot(y, color="blue", linewidth=4, label="Effort respect to time")
    plt.vlines(x=td,ymin=0,ymax=round(Jensen(k,td,td),5),color="green", linestyle="dashed",linewidth=4,label=td)
    plt.vlines(x=t,ymin=0,ymax=round(Jensen(k,td,t),5),color="red",linestyle="dashed", linewidth=4,label="t")
    plt.legend(loc="upper right")
    plt.xlabel("time")
    plt.ylabel("Effort per unit time")
    plt.title("r_curve")
    plt.show()
  


#if _name_== "_main_":
print("Jensen formula")
C=float(input("Enter the effective technology  constant:"))
T=float(input("Enter the development time:"))
K=float(input("Enter the effort needed to develop:"))
L=C*T*pow(K,1/3)
print("The product size is: ",L,"KLOC")


k=C
td=T
t=K
#p=2*(pow(td,2))
#q=pow(t,2)
#r=pow(2.7182,(-q/p))
#E=((k/pow(td,2))*t*r)
#print("E=",E,"PM")
print("required effort at time t, E--", round(Jensen(k,td,t),5),"PM\n\n")
R_curve(k,td,t)cts are categorized into three types:

# Jensen's work for software development
import matplotlib.pyplot as plt
cts are categorized into three types:
effort = int(input("Enter effort(developers) need to develop the software: "))
time = int(input("Enter estimated time for develop a software(in months): "))
# time = 0.3935 * effort
# print("Estimated time for develop a software(in months): " + str(time))
tc = [2,8,11]

def relay_graph():
  print("\n")
  
  plt.legend(loc="upper right")
  plt.xlabel("time") 
  plt.ylabel("product size")
  plt.title("r_curve for Jensen")
  plt.show()

def jensen(tc,effort,time): 
  return tc * time * pow(effort, 1/2)

colors = {
      2: 'blue',
      8: 'red',
      11: 'cyan'
  }

# for records in tc:
#   points = []
#   kloc = str(putnam(records,effort,time))
#   project_duration = 3 * int(time)
#   for timeTaken in range(0, project_duration):
#     points.append(round(putnam(records, effort, timeTaken), 5))
#   plt.plot(points, color=colors[records], linewidth=4, label=f"TC: {records} | KLOC: {kloc}")
#   relay_graph()

points = []
k = []
for records in tc:
  a = []
  kloc = str(jensen(records,effort,time))
  project_duration = 3 * int(time)
  for timeTaken in range(0, project_duration):
    a.append(round(jensen(records, effort, timeTaken), 5))
  
  points.append(a)
  k.append(kloc)
  plt.plot(a, color=colors[records], linewidth=4, label=f"TC: {records} | KLOC: {kloc}")
  relay_graph()
i = 0
for records in tc:
  plt.plot(points[i], color=colors[records], linewidth=4, label=f"TC: {records} | KLOC: {k[i]}")
  i += 1
relay_graph()

import matplotlib.pyplot as plt


def jensen(c, t, k):
    return c*t*pow(k,1/2)


def relay_graph(c, t, k):
    pass
    project_duration = 3 * int(t)
    y = [round(jensen(c, time, k), 5) for time in range(0, project_duration)]
    plt.plot(y, color="red", linewidth=4, label="Effort respect to time")
    plt.legend(loc="upper right")
    plt.xlabel("time")
    plt.ylabel("Effort per unit time")
    plt.title("r_curve for jensen")
    plt.show()


if __name__ == "__main__":
    print("###################   Jensen formula   ###################")
    c = float(input("Enter the effective technology constant:"))
    t = float(input("Enter the development time:"))
    k = float(input("Enter the effort needed to develop:"))
    
    l = jensen(c, t, k)
    print("The product size is: ", l ,"KLOC")
    relay_graph(c, t, k)